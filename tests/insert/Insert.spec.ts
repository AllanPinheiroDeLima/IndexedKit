import { DatabaseNotDefinedError } from "@src/errors/DatabaseNotDefined.error";
import { InvalidInputError } from "@src/errors/InvalidaInput.error";
import { DataStore } from "@src/index";
import { afterAll, describe, expect, it } from "vitest";

describe("Insert", () => {
  const databaseName = process.env.DATASTORE_DATABASE_NAME;
  const collectionName = process.env.DATASTORE_COLLECTION_NAME;
  
  const dataToInsert = Object.freeze({ title: "Quarry Memories", author: "Fred", isbn: 123456 });
  
  afterAll(() => {
    var request = indexedDB.open(databaseName, 3);

    request.onupgradeneeded = function () {
      const db = request.result;
      const store = db.createObjectStore(collectionName);

      store.openCursor().onsuccess = function(event) {
        // QUANDO AS TIPAGENS FOREM CORRIGIDAS, ISSO VAI DAR ERRO
        // QUANDO ISSO ACONTECER, É SÓ REMOVER ESSES COMENTÁRIOS
        // @ts-expect-error
        var cursor = event.target?.result;
        if (cursor) {
          store.delete(cursor.primaryKey);
          cursor.continue();
        }
      }
    }
  })
  it("should throw an error when not using init before using the insert method", async () => {
    const datastore = new DataStore(databaseName, collectionName);

    const fnCall = () => datastore.insert({ title: "Quarry Memories", author: "Fred", isbn: 123456 }); 

    expect(fnCall()).rejects.toThrowError("COD001: DATABASE_NOT_INITIALIZED");
    expect(fnCall()).rejects.toThrowError(DatabaseNotDefinedError);
  });

  it("should insert an item into the database with the id defined", async () => {
    const datastore = new DataStore(databaseName, collectionName);
    await datastore.init();

    const inserted = await datastore.insert(dataToInsert); 

    expect(inserted).toStrictEqual({
      id: expect.any(String),
      ...dataToInsert
    });
  });

  it("should insert an item into the database ignoring the defined id", async () => {
    const datastore = new DataStore(databaseName, collectionName);
    await datastore.init();

    const inserted = await datastore.insert({
      id: "teste",
      ...dataToInsert
    }); 

    expect(inserted).toStrictEqual({
      id: expect.not.stringMatching("teste"),
      ...dataToInsert
    });
  });

  it("should throw an error then the user tries to insert primitive values or function", async () => {
    const datastore = new DataStore(databaseName, collectionName);
    await datastore.init();

    const insertedNumber = () => datastore.insert(1); 
    const insertedString = () => datastore.insert("string"); 
    const insertedBoolean = () => datastore.insert(false);  
    const insertedFunction = () => datastore.insert(() => {});  

    // THE UNDEFINED AND NULL CASES ARE FOR TESTING AGAINST FORCING THE TYPES
    // ON THE input LEVEL
    // @ts-expect-error
    const insertedNull = () => datastore.insert(null);  
    // @ts-expect-error
    const insertedUndefined = () => datastore.insert(undefined);

    expect(insertedNumber()).rejects.toThrowError(InvalidInputError);
    expect(insertedString()).rejects.toThrowError(InvalidInputError);
    expect(insertedBoolean()).rejects.toThrowError(InvalidInputError);
    expect(insertedFunction()).rejects.toThrowError(InvalidInputError);
    expect(insertedNull()).rejects.toThrowError(InvalidInputError);
    expect(insertedUndefined()).rejects.toThrowError(InvalidInputError);
    
  });

  it.todo("should insert an array correctly into the database", async () => {})
  it.todo("should insert an item with an id when the generateId alg is defined", async () => {})
  it.todo("should insert an item with an id generated by the idGenerator", async () => {})
  it.todo("should use the 'id' defined in the keyPath option", async () => {})
  it.todo("should create the indexes correctly when defined", async () => {})
})